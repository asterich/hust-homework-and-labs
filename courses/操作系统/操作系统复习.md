[TOC]

# 操作系统复习

## 第1章 绪论

#### 演变史

1. 手工操作

2. 批处理

   - 联机批处理：IO由cpu直接控制
   - 脱机批处理：由主机和卫星机组成，其中卫星机负责IO，主机负责计算；DMA技术原型

3. 执行系统：引入了**通道**和**中断**，并行化了主机和外设

   - 这也是多道程序设计的基础

4. 操作系统

   - **多道程序设计**

     - 特征
       - **多道**：**内存中**存放多个相互独立程序
       - 宏观上并行（相互穿插）
       - 微观上串行（单CPU）

     - 物质基础：**足够容量的主存**
     - 多道程序设计还是用在脱机批处理系统上，不算操作系统；**不可抢占**

   - **分时技术**：将处理机时间划分为很短的时间片，轮流分配给各个程序使用

     - 分时技术已经用在了分时操作系统上

#### 操作系统的定义和特点

1. 定义：是一个大型的软件系统，它负责计算机系统软、硬件资源的分配，控制和协调并发活动，提供给用户和其他软件方便的接口和环境，使用户获得良好的工作环境。
2. **特点**
   - **并发**：两个以上事件在同一时间间隔内发生
   - **共享**：系统中的资源可供多个并发执行的进程共同使用
     - 两种共享方式：时分复用（例如两个程序共享CPU）和空分复用（例如在内存中放多道程序）
   - **虚拟**：将物理实体变成若干逻辑上的对应物
   - **不确定性**（异步性）：多个作业的执行顺序和每个作业的执行时间是不确定的

## 第2+3章 操作系统的物质基础和结构

#### 操作系统的物质基础

1. **操作系统的物质基础**：
   - CPU特权级

   - 中断

   - 时钟

   - DMA

2. **CPU特权级**
   - **为什么**：操作系统的管理程序和用户程序职责不同，权限也应该不同；管理程序不能被破坏，特权级是为了保护操作系统
   - 分类：大致可分管态和用户态，管态下处理器能够运行所有指令
     - 特权指令：IO、访问MMIO的指令、改变机器状态寄存器的指令
   - 切换：中断请求；系统调用；异常

3. **中断**
   - 为什么：用户态执行程序需要内核态帮助，应该提供一种机制让用户态能够转换到内核态
   - 本质：受保护的状态转换
   - 分类：异常、系统调用、IRQ(riscv也叫interrupt)
   - 过程
     - 中断进入（硬件）：进入高优先级
     - 中断处理（软件，由操作系统内核实现）：保护现场、处理中断、调用中断返回指令
     - 中断返回（硬件）：恢复现场、回到低优先级

4. 时钟

5. DMA

#### 操作系统的结构

1. 组件
   - 核心组件：中断管理、进程管理、进程调度、内存管理
   - 外围组件：设备管理、文件系统
2. 结构分类
   - 宏内核：操作系统组件全部运行在内核态下
     - 优点：系统结构简单；省去了微内核IPC开销
     - 缺点：内核庞大，容易崩溃
   - 微内核：操作系统核心组件放在内核中，外围组件放在用户态
     - 优点：内核小，比较安全稳定
     - 缺点：进程间IPC，效率偏低
   - 伴生内核（Exokernel）

#### 链接

#### 用户接口

## 第4章 进程

#### 进程的引入

1. 并发程序的特点
   - 失去程序封闭性和可再现性
   - 程序和计算不再一一对应
   - 程序并发执行的相互制约
2. 时间有关的错误：共享了公共变量，执行结果与并发程序的相对速度有关

#### 进程概念

1. 什么是进程：就是一个程序在给定**活动空间**和**初始环境**下，在一个处理机上的**执行过程**
2. 进程与程序的区别

   - 程序是**静态**的概念，进程是**动态**的概念
   - 进程是一个**独立运行**的活动单位
   - 进程是**竞争系统资源**的基本单位
   - 一个程序可以对应多个进程，一个进程至少包含一个程序
3. **进程的状态**

   1. 进程的状态
      - 运行（在cpu上跑）
      - 等待（暂停执行，等待某事件发生，常见于磁盘IO等）
      - 就绪（获得除了cpu外运行所需资源）
   2. 状态变迁
      - 就绪->运行：被调度到
      - 运行->等待：服务请求（例如IO）或等待事件
      - 等待->就绪：事件来到/完成服务请求
      - 运行->就绪：时间片到
4. 进程组成

   - 程序与数据

   - 进程控制块PCB

     - **进程标识符**
     - **当前状态**
     - 当前状态队列指针next
     - 进程优先级
     - **cpu现场保护区**
     - 进程间通信信息
     - 家族信息
     - 占有资源清单
5. **线程**：比进程更小的活动单位，进程中的一个执行路径
   - 它有自己的**栈和CPU上下文**，但是线程间共享**进程的地址空间**

#### 进程控制

不看了

#### 进程的并发

1. 相关概念

   1. **临界资源**：一次仅允许一个进程使用的资源
   2. **临界区**：多个进程/线程对一个**公共变量**进行**读**或**写**的程序段
   3. **互斥**：某一进程正在访问某存储区域时，不允许其他进程来读/写这个存储区的内容，这样的相互制约关系称为互斥
   4. **进程同步**：并发进程在一些地方需要**互相等待**、**互通消息**，称之为进程同步

2. **锁**

3. **信号量**

   - 信号量**非负**时进程执行，否则block；信号量的**初值很重要**
   - 信号量有两个操作**P**和**V**
     - P操作又名wait操作，将信号量-1
     - V操作又名signal操作，将信号量+1

4. **常见并发模式的信号量实现**

   1. 进程互斥

      ```c
      int main() {
          
          __global__ int x = 1;
          
          /*
          	1  表示没有进程进入临界区；
          	0  表示有一个进程进入临界区；
          	-1 表示有一个进程已经进入临界区，另一个进程正在等待
          */
          semaphore mutex = 1;
          
          cobegin;
          p1(); p2();
          coend;
          return 0;
      }
      
      void p1() {
          //...
          P(mutex);
          x = x + 1;
          V(mutex);
          //...
      }
      
      void p2() {
          //...
          P(mutex);
          x = x + 1;
          V(mutex);
          //...
      }
      ```

      

   2. 进程同步

      ```c
      /*
       * 假设流图如下：
       *  p1       p2
       *   \       /
       *    \     /
       *     \   /
       *       p3
       */
      
      int main() {
          semaphore s13 = 0, s23 = 0;
          cobegin
              p1; p2; p3;
          coend
          return 0;
      }
      
      void p1() {
          // ...
          V(s13);
      }
      void p2() {
          // ...
          V(s23);
      }
      void p3() {
          P(s13);
          P(s23);
          // ...
      }
      ```

      

   3. 生产者/消费者问题

      ```c
      int main() {
          
          semaphore mutex = 1, empty = n, full = 0;
          cobegin
              producer; consumer;
          coend
          return 0;
      }
      
      void producer() {
          while (produce not finished) {
              produce;
              P(empty);
              P(mutex);
              put one product into buffer;
              V(mutex);
              V(full);
          }
      }
      
      void consumer() {
          while (consume not finished) {
              P(full);
              P(mutex);
              take out one product from buffer;
              V(mutex);
              V(empty);
          }
      }
      ```

      

   4. 读者/写者问题

      ```c
      // reader preference
      // the problem is that write process will starve
      int main() {
          global int rd_cnt = 0;
          semaphore w_sem = 1, cnt_sem = 1;
          cobegin
              reader_i; writer;
          coend
          return 0;
      }
      
      void reader_i() {
          while (time to read) {
              P(cnt_sem);
              rd_cnt++;
              if (rd_cnt > 0)
                  P(w_sem);
              V(cnt_sem);
      
              read;
      
              P(cnt_sem);
              rd_cnt--;
              if (rd_cnt <= 0)
                  V(w_sem);
              V(cnt_sem);
          }
      }
      
      void writer() {
          while (time to write) {
              P(wsem);
              write;
              V(wsem);
          }
      }
      
      // writer preference
      int main() {
          global int rd_cnt = 0;
          semaphore w_sem = 1, cnt_sem = 1, rd_try = 1;
          cobegin
              reader_i; writer;
          coend
          return 0;
      }
      
      void reader_i() {
          while (time to read) {
              P(rd_try);
              P(cnt_sem);
              rd_cnt++;
              if (rd_cnt > 0)
                  P(w_sem);
              V(cnt_sem);
              V(rd_try);
      
              read;
      
              P(cnt_sem);
              rd_cnt--;
              if (rd_cnt <= 0)
                  V(w_sem);
              V(cnt_sem);
          }
      }
      
      void writer() {
          while (time to write) {
              P(rd_try);
              P(wsem);
              write;
              V(wsem);
              V(rd_try);
          }
      }
      ```

      

#### 进程调度

1. 调度/分派
   - **调度**：从就绪状态进程中选一个
   - **分派**：处理机空闲时把调度选出来的进程放到处理机上运行
2. 功能
   - 进程管理的数据结构
   - 决定调度策略
   - 实施处理机分配和回收
3. **调度方式**
   - **非剥夺**：某个**重要急迫进程**来到时，现在正在运行的进程继续执行
   - **剥夺**：某个**重要急迫进程**来到时，把正在运行的进程调度出去
4. **进程调度算法**
   1. 进程优先数调度算法：确定进程的优先数，调度时把最高优先级的放到处理机上
      - 优先数分类
        - 静态优先数：进程创建时确定，一经确定整个进程运行期间不再改变
        - 动态优先数：在进程运行期间可以改变
   2. 循环轮转调度算法：每次调度时选就绪队列首元素，赋予一个时间片，调度出去后把它插入队列末端
      - 时间片的长度是可变的
5. 调度的状态变迁

![image-20240104170726542](C:\Users\asterich\AppData\Roaming\Typora\typora-user-images\image-20240104170726542.png)

​	伟大，无需多言😅



## 第5章 资源分配和调度

#### 死锁

1. 定义：多个并发进程中，每个进程**持有某种资源**的同时，又**等待别的进程释放它们的资源**，使得程序**不能向前推进**。
2. **四个必要条件**
   - 互斥：涉及的资源是临界资源
   - 不剥夺：进程的资源在没用完之前，不能被其他进程强行夺走
   - 部分分配（请求和保持）：进程每次申请它所需要的一部分资源，在等待一个新资源的同时，进程继续占用已分配的资源
   - 环路条件：存在一种进程循环链，链中每一个进程已获得的资源同时被链中下一个进程请求
3. **处理策略**
   - 预防死锁：采用静态策略控制资源分配，让系统不可能发生死锁，简单但是资源利用率较低
     - 核心思想：破坏死锁四个必要条件之一
       - 互斥：spooling
       - 不剥夺：改造申请者或占用者
         - 改造申请者：申请者申请不到资源时，必须释放所有持有的资源
         - 改造占用者：可以让操作系统帮忙，强行剥夺占用资源
       - 请求和保持：静态资源分配，进程必须一次申请完它需要的资源
       - 环路：有序资源分配法，分配请求按资源编号的上升序进行
   - 避免死锁：只在资源分配时做判断，若不死锁才分配，能提高资源利用率，但是每次资源分配时要计算
     - **银行家算法**
   - 解除死锁：允许死锁发生，操作系统来检测和解除

## 第6章 处理机调度

1. 调度性能的衡量
   - **周转时间**(**响应时间**)：各作业**提交**给计算机系统到该作业的结果返回用户（**作业完成**）所需要的时间，即作业在系统中停留时间长短
     - 平均周转时间：周转时间取平均
   - **带权周转时间**：作业**周转时间**与其**运行时间**比值，说明作业在系统中的相对等待时间
     - 平均带权周转时间：带权取平均
2. **调度算法**
   1. 先来先服务：每次选择等得最久的作业
   2. 短作业优先：每次选择请求运行时间最小的作业
   3. 响应比高者优先调度
      - 响应比：1+等待时间/运行时间
